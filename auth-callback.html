<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GhostOps — Validation de connexion</title>
    <meta name="robots" content="noindex, nofollow" />
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
        margin: 0;
        background: #0b0f19;
        color: #e6e8ee;
        display: grid;
        place-items: center;
        min-height: 100vh;
      }
      .card {
        width: min(560px, calc(100vw - 32px));
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 22px;
      }
      h1 { font-size: 18px; margin: 0 0 8px; }
      p { margin: 0; opacity: 0.9; line-height: 1.5; font-size: 13px; }
      .err { margin-top: 10px; color: #ff7c7c; }
      .muted { margin-top: 10px; opacity: 0.75; font-size: 12px; }
      a { color: #cdd6ff; text-decoration: underline; }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>Validation de connexion…</h1>
      <p>Veuillez patienter, vous allez être redirigé automatiquement.</p>
      <p id="err" class="err" style="display:none;"></p>
      <p class="muted">
        Si rien ne se passe, <a href="/connexion.html">retourner à la page de connexion</a>.
      </p>
    </div>

    <!-- 1) SDK Supabase (navigateur) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- 2) Votre config -->
    <script src="/config.js"></script>

    <script>
      (function () {
        const supabase = window.ghostopsSupabase;
        const errEl = document.getElementById("err");

        function showErr(msg) {
          errEl.textContent = msg;
          errEl.style.display = "block";
        }

        function sanitizeInternalPath(p, fallback) {
          const fb = fallback ?? "/index.html";
          let v = String(p || "").trim();
          if (!v) return fb;

          // Refuser URLs absolues
          if (v.startsWith("http://") || v.startsWith("https://")) return fb;

          // Si "next" arrive encodé (%2F...%3F...)
          try {
            if (/%2F|%3F|%3D/i.test(v)) v = decodeURIComponent(v);
          } catch (_) {}

          if (!v.startsWith("/")) v = "/" + v;
          if (v.includes("..")) return fb;

          return v;
        }

        function getNextFromUrl() {
          const u = new URL(window.location.href);
          const n = u.searchParams.get("next");
          return sanitizeInternalPath(n, null);
        }

        function getStoredNext() {
          try {
            return sanitizeInternalPath(localStorage.getItem("ghostops_return_to"), null);
          } catch {
            return null;
          }
        }

        function buildConnexionUrl(reason, next) {
          const u = new URL("/connexion.html", window.location.origin);
          if (reason) u.searchParams.set("reason", reason);
          if (next) u.searchParams.set("next", next);
          return u.toString();
        }

        function clearSensitiveUrlArtifacts() {
          // Optionnel : nettoyer l’URL (hash ou params) après traitement
          // Évite de laisser traîner des tokens dans l’historique.
          try {
            const u = new URL(window.location.href);
            // on conserve uniquement "next" si présent
            const keepNext = u.searchParams.get("next");
            const clean = new URL(u.origin + u.pathname);
            if (keepNext) clean.searchParams.set("next", keepNext);
            window.history.replaceState({}, "", clean.toString());
          } catch (_) {}
        }

        async function waitForSession(maxMs) {
          const start = Date.now();
          while (Date.now() - start < maxMs) {
            try {
              const { data } = await supabase.auth.getSession();
              if (data?.session) return data.session;
            } catch (_) {}
            await new Promise((r) => setTimeout(r, 150));
          }
          return null;
        }

        async function run() {
          if (!supabase?.auth) {
            showErr("Supabase non initialisé. Vérifiez /config.js et le chargement du SDK.");
            setTimeout(() => {
              window.location.href = buildConnexionUrl("supabase_missing", "/index.html");
            }, 900);
            return;
          }

          // 1) Déterminer la cible (avant toute redirection)
          const nextFromUrl = getNextFromUrl();
          const nextStored = getStoredNext();
          const target = nextFromUrl || nextStored || "/index.html";

          // 2) Laisser Supabase traiter l'URL (code/token) et installer la session
          // Selon la config, ça peut être sync/async côté SDK. On “attend” une session réelle.
          try {
            await supabase.auth.getSession();
          } catch (_) {
            // On ne conclut pas encore : on va quand même attendre une session quelques ms
          }

          // 3) Attendre une session réelle (évite les faux positifs)
          const session = await waitForSession(1500);

          if (!session) {
            showErr("Connexion non finalisée (session absente). Reconnexion requise.");
            setTimeout(() => {
              window.location.href = buildConnexionUrl("no_session", target);
            }, 1100);
            return;
          }

          // 4) Nettoyage optionnel
          clearSensitiveUrlArtifacts();

          // 5) Redirection finale
          window.location.replace(target);
        }

        run();
      })();
    </script>
  </body>
</html>
