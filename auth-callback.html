<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>GhostOps — Validation de connexion</title>
    <meta name="robots" content="noindex, nofollow" />
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
        margin: 0;
        background: #0b0f19;
        color: #e6e8ee;
      }
      .wrap {
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 24px;
      }
      .card {
        width: min(720px, 92vw);
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 22px;
        text-align: center;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 10px;
      }
      p {
        margin: 0;
        opacity: 0.9;
        line-height: 1.5;
        font-size: 14px;
      }
      .msg {
        margin-top: 14px;
        font-size: 13px;
      }
      .ok {
        color: #7cffb2;
      }
      .err {
        color: #ff7c7c;
      }
      .muted {
        opacity: 0.75;
        margin-top: 10px;
        font-size: 12px;
      }
      a {
        color: #cdd6ff;
      }
    </style>

    <!-- 1) SDK Supabase (navigateur) + 2) config.js (doit créer window.ghostopsSupabase) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="/config.js"></script>
  </head>

  <body>
    <div class="wrap">
      <div class="card">
        <h1>Connexion en cours…</h1>
        <p>Nous finalisons votre session sécurisée. Vous allez être redirigé automatiquement.</p>
        <div id="msg" class="msg"></div>
        <div class="muted">
          Si la redirection ne se fait pas, <a href="/connexion.html">retournez à la page de connexion</a>.
        </div>
      </div>
    </div>

    <script>
      (function () {
        const msg = document.getElementById("msg");
        function setMsg(text, cls) {
          msg.textContent = text || "";
          msg.className = "msg " + (cls || "");
        }

        function sleep(ms) {
          return new Promise((r) => setTimeout(r, ms));
        }

        async function waitForSupabaseClient(timeoutMs = 6000) {
          const start = Date.now();
          while (Date.now() - start < timeoutMs) {
            if (window.ghostopsSupabase?.auth) return window.ghostopsSupabase;
            await sleep(50);
          }
          return null;
        }

        // ✅ Sécurité : n'autoriser que des chemins internes
        function sanitizeInternalPath(p, fallback) {
          const fb = fallback || "/index.html";
          const v = String(p || "").trim();
          if (!v) return fb;
          if (v.startsWith("http://") || v.startsWith("https://")) return fb;
          if (!v.startsWith("/")) return "/" + v;
          return v;
        }

        function getQueryParam(name) {
          const u = new URL(window.location.href);
          return u.searchParams.get(name);
        }

        function getHashParams() {
          const h = window.location.hash?.startsWith("#") ? window.location.hash.slice(1) : "";
          return new URLSearchParams(h);
        }

        // ✅ Nettoyage URL (retire tokens + code)
        function cleanUrlKeepNext(nextPath) {
          const base = "/auth-callback.html";
          if (nextPath) {
            history.replaceState(null, "", `${base}?next=${encodeURIComponent(nextPath)}`);
          } else {
            history.replaceState(null, "", base);
          }
        }

        (async () => {
          try {
            const supabase = await waitForSupabaseClient();
            if (!supabase) {
              throw new Error("Client Supabase indisponible (config.js non chargé).");
            }

            // ✅ cible finale
            const nextRaw = getQueryParam("next");
            const next = sanitizeInternalPath(nextRaw, "/index.html");

            // Supabase peut revenir :
            // - soit en PKCE : ?code=...
            // - soit en implicit : #access_token=...&refresh_token=...
            const url = new URL(window.location.href);
            const code = url.searchParams.get("code");

            const hash = getHashParams();
            const access_token = hash.get("access_token");
            const refresh_token = hash.get("refresh_token");

            // Gestion erreurs éventuelles dans le hash
            const error = hash.get("error");
            const error_description = hash.get("error_description");
            if (error || error_description) {
              throw new Error(decodeURIComponent(error_description || error));
            }

            if (code) {
              // ✅ PKCE : échange du code contre une session
              const { data, error: exErr } = await supabase.auth.exchangeCodeForSession(code);
              if (exErr) throw exErr;

              cleanUrlKeepNext(next);
              setMsg("Connexion validée. Redirection…", "ok");

              // petite latence anti-race condition
              setTimeout(() => {
                window.location.replace(next);
              }, 250);

              return;
            }

            if (access_token && refresh_token) {
              // ✅ Implicit : setSession avec tokens
              const { error: setErr } = await supabase.auth.setSession({
                access_token,
                refresh_token,
              });
              if (setErr) throw setErr;

              cleanUrlKeepNext(next);
              setMsg("Connexion validée. Redirection…", "ok");

              setTimeout(() => {
                window.location.replace(next);
              }, 250);

              return;
            }

            // ✅ Dernier filet : si déjà connecté (session existante) on redirige
            const { data } = await supabase.auth.getSession();
            if (data?.session) {
              cleanUrlKeepNext(next);
              setMsg("Session déjà active. Redirection…", "ok");
              setTimeout(() => window.location.replace(next), 200);
              return;
            }

            throw new Error("Lien invalide ou expiré. Veuillez relancer une connexion.");
          } catch (e) {
            setMsg("Erreur : " + (e?.message || "Impossible de finaliser la connexion."), "err");
          }
        })();
      })();
    </script>
  </body>
</html>
