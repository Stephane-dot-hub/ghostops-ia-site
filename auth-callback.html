<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>GhostOps — Validation de connexion</title>
    <meta name="robots" content="noindex, nofollow" />
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
        margin: 0;
        background: #0b0f19;
        color: #e6e8ee;
      }
      .wrap {
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 24px;
      }
      .card {
        width: min(720px, 92vw);
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 22px;
        text-align: center;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 10px;
      }
      p {
        margin: 0;
        opacity: 0.9;
        line-height: 1.5;
        font-size: 14px;
      }
      .msg {
        margin-top: 14px;
        font-size: 13px;
      }
      .ok {
        color: #7cffb2;
      }
      .err {
        color: #ff7c7c;
      }
      .muted {
        opacity: 0.75;
        margin-top: 10px;
        font-size: 12px;
      }
      a {
        color: #cdd6ff;
      }
    </style>

    <!-- 1) Charger supabase-js (UMD) puis 2) votre config.js -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <script src="/config.js"></script>
  </head>

  <body>
    <div class="wrap">
      <div class="card">
        <h1>Connexion en cours…</h1>
        <p>Nous finalisons votre session sécurisée. Vous allez être redirigé automatiquement.</p>
        <div id="msg" class="msg"></div>
        <div class="muted">
          Si la redirection ne se fait pas, <a href="/connexion.html">retournez à la page de connexion</a>.
        </div>
      </div>
    </div>

    <script>
      const msg = document.getElementById("msg");
      function setMsg(text, cls) {
        msg.textContent = text || "";
        msg.className = "msg " + (cls || "");
      }

      function getHashParams() {
        // Retire le '#' puis parse comme une querystring
        const h = window.location.hash?.startsWith("#") ? window.location.hash.slice(1) : "";
        return new URLSearchParams(h);
      }

      async function waitForSupabaseClient(timeoutMs = 4000) {
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
          if (window.ghostopsSupabase?.auth) return window.ghostopsSupabase;
          await new Promise((r) => setTimeout(r, 50));
        }
        return null;
      }

      (async () => {
        try {
          const supabase = await waitForSupabaseClient();
          if (!supabase) {
            throw new Error("Client Supabase indisponible (config.js non chargé).");
          }

          const params = getHashParams();
          const access_token = params.get("access_token");
          const refresh_token = params.get("refresh_token");
          const error_description = params.get("error_description");
          const error = params.get("error");

          if (error || error_description) {
            throw new Error(decodeURIComponent(error_description || error));
          }

          if (!access_token || !refresh_token) {
            // Cas fréquent : l'utilisateur ouvre auth-callback sans token
            throw new Error("Lien invalide ou expiré. Veuillez relancer une connexion.");
          }

          // Crée la session à partir des tokens du hash
          const { data, error: setErr } = await supabase.auth.setSession({
            access_token,
            refresh_token,
          });

          if (setErr) throw setErr;

          // Nettoyage URL (retire le hash avec tokens)
          history.replaceState(null, "", "/auth-callback.html");

          // Redirection cible (à adapter)
          const target = "/espace.html";
          setMsg("Connexion validée. Redirection…", "ok");

          // Petite latence pour éviter certains cas de race condition
          setTimeout(() => {
            window.location.href = target;
          }, 350);
        } catch (e) {
          setMsg("Erreur : " + (e?.message || "Impossible de finaliser la connexion."), "err");
        }
      })();
    </script>
  </body>
</html>
