<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>GhostOps Studio Scénarios – Espace IA Niveau 2</title>
    <meta
      name="description"
      content="Espace IA sécurisé du GhostOps Studio Scénarios : construction de 2 à 3 scénarios tactiques comparables à partir de votre Diagnostic IA ou de votre dossier consolidé."
    />
    <meta name="robots" content="noindex, nofollow" />
    <link rel="canonical" href="https://www.ghostops.tech/studio-scenarios-session.html" />

    <!-- Open Graph -->
    <meta property="og:title" content="GhostOps Studio Scénarios – Espace IA Niveau 2" />
    <meta
      property="og:description"
      content="Module IA dédié au GhostOps Studio Scénarios : scénarios tactiques, matrices risques/gains/exposition et conditions de faisabilité."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://www.ghostops.tech/studio-scenarios-session.html" />
    <meta property="og:image" content="https://www.ghostops.tech/assets/ghostops-opengraph.jpg" />

    <!-- Fonts & Tailwind -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = { theme: { extend: { fontFamily: { sans: ["Inter", "sans-serif"] } } } };
    </script>

    <!-- ✅ Supabase (navigateur) + config.js -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="/config.js"></script>

    <!-- ✅ Niveau produit (canonique) -->
    <script>
      window.GHOSTOPS_NIVEAU_PRODUIT = "studio-scenarios";
    </script>

    <!-- ✅ Orchestrateur : activation si cs_id, puis auth-guard -->
    <script>
      (function () {
        const params = new URLSearchParams(window.location.search);
        const csId = (params.get("cs_id") || "").trim();
        const niveauProduit = window.GHOSTOPS_NIVEAU_PRODUIT; // "studio-scenarios"
        const DEBUG = params.get("debug") === "1";

        function log(...a) {
          if (DEBUG) console.log("[GhostOps Studio Orchestrator]", ...a);
        }

        function loadAuthGuard() {
          // Évite double chargement
          if (window.__GHOSTOPS_AUTH_GUARD_LOADED) return;
          window.__GHOSTOPS_AUTH_GUARD_LOADED = true;

          const s = document.createElement("script");
          s.src = "/js/auth-guard.js";
          s.defer = true;
          document.head.appendChild(s);
        }

        async function waitSupabaseReady(timeoutMs) {
          const t0 = Date.now();
          while (Date.now() - t0 < timeoutMs) {
            const sb = window.ghostopsSupabase;
            if (sb && sb.auth && typeof sb.auth.getSession === "function") return sb;
            await new Promise((r) => setTimeout(r, 60));
          }
          return null;
        }

        async function getAccessTokenWithRetry(sb, timeoutMs) {
          const t0 = Date.now();
          while (Date.now() - t0 < timeoutMs) {
            try {
              const { data } = await sb.auth.getSession();
              const token = data?.session?.access_token || "";
              if (token) return token;
            } catch (_) {}
            await new Promise((r) => setTimeout(r, 120));
          }
          return "";
        }

        async function activateRight(sb, accessToken) {
          const r = await fetch("/api/ghostops-activate-right", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: "Bearer " + accessToken,
            },
            body: JSON.stringify({ cs_id: csId, niveau_produit: niveauProduit }),
          });

          const j = await r.json().catch(() => ({}));
          if (!r.ok || !j.ok) {
            throw new Error(j.error || "Activation impossible");
          }
          return true;
        }

        function cleanUrlAfterActivation() {
          const url = new URL(window.location.href);
          url.searchParams.delete("cs_id");
          url.searchParams.set("paid", "1");
          url.searchParams.set("activated", "1");
          window.location.replace(url.toString());
        }

        async function run() {
          // Cas standard : pas de cs_id => on charge l’auth-guard immédiatement
          if (!csId) {
            loadAuthGuard();
            return;
          }

          // Cas paiement : cs_id présent => on tente d’activer le droit, puis on charge l’auth-guard
          log("cs_id détecté, tentative activation…", csId);

          const sb = await waitSupabaseReady(2500);
          if (!sb) {
            // Supabase pas prêt : on charge quand même l’auth-guard qui gérera "supabase_missing"
            loadAuthGuard();
            return;
          }

          // On a besoin d’une session (access token) pour activer côté API
          const accessToken = await getAccessTokenWithRetry(sb, 2500);

          if (!accessToken) {
            // Pas de session => renvoyer vers connexion en conservant cs_id dans next
            const next = window.location.pathname + window.location.search;
            const q = new URLSearchParams();
            q.set("next", next);
            q.set("reason", "no_session");
            window.location.assign("/connexion.html?" + q.toString());
            return;
          }

          // Anti-boucle : une seule tentative d’activation par cs_id dans cette session navigateur
          const onceKey = "ghostops_activate_once_" + niveauProduit + "_" + csId;
          if (sessionStorage.getItem(onceKey) === "1") {
            log("activation déjà tentée, on charge auth-guard");
            loadAuthGuard();
            return;
          }
          sessionStorage.setItem(onceKey, "1");

          try {
            await activateRight(sb, accessToken);
            log("activation OK, nettoyage URL…");
            cleanUrlAfterActivation();
            return; // stop : reload
          } catch (e) {
            console.error("[GhostOps activate-right] error:", e);
            // Si activation échoue : on charge auth-guard, qui redirigera vers produit (no_right) si besoin
            loadAuthGuard();
            return;
          }
        }

        run();
      })();
    </script>

    <style>
      body::before {
        content: "";
        background: url("/assets/background-ghostops.jpg") no-repeat center center fixed;
        background-color: #0f172a;
        background-size: cover;
        animation: bgPulse 10s ease-in-out infinite alternate;
        position: fixed;
        inset: 0;
        opacity: 0.25;
        z-index: -1;
        transition: opacity 0.4s ease;
      }
      @keyframes bgPulse {
        0% { filter: brightness(1) contrast(1); }
        100% { filter: brightness(1.05) contrast(1.05); }
      }
      .text-shadow { text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.6); }
      html { scroll-behavior: smooth; }
      header, main, section, footer { position: relative; z-index: 1; }

      /* Bulles lisibles + aération */
      .bot-bubble { white-space: normal; line-height: 1.6; }
      .bot-bubble p { margin: 0.35rem 0; }
      .bot-bubble p + p { margin-top: 0.45rem; }
      .bot-bubble ul { list-style: disc; padding-left: 1.25rem; margin: 0.4rem 0 0.5rem 0; }
      .bot-bubble li { margin: 0.18rem 0; }
      .bot-bubble strong { font-weight: 700; }
      .bot-bubble .section-title { display: block; margin: 0.65rem 0 0.25rem 0; }

      .ghostops-btn { border: 1px solid rgba(148, 163, 184, 0.35); }
      .ghostops-chip {
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.55);
        backdrop-filter: blur(6px);
      }
      .ghostops-muted { color: rgba(226, 232, 240, 0.75); }
      .disabled { opacity: 0.55; pointer-events: none; filter: grayscale(0.15); }
    </style>
  </head>

  <body class="bg-gray-900 text-white font-sans leading-relaxed">
    <!-- HEADER -->
    <header class="w-full px-6 md:px-16 py-4 flex items-center justify-between">
      <a href="/index.html" class="text-sm font-semibold tracking-[.25em] text-gray-200 hover:text-white uppercase">
        GHOST<span class="text-gray-400">OPS</span>
      </a>
      <nav class="flex items-center gap-4 text-xs md:text-sm">
        <a href="/index.html" class="text-gray-300 hover:text-white">Accueil</a>
        <a href="/expertise.html" class="text-gray-300 hover:text-white">Expertise</a>
        <a href="/qui-sommes-nous.html" class="text-gray-300 hover:text-white">Qui sommes-nous&nbsp;?</a>
        <a
          href="/contact.html"
          class="px-3 py-1 border border-gray-400 rounded-full hover:bg-gray-100 hover:text-black transition"
        >
          Contact confidentiel
        </a>
      </nav>
    </header>

    <main class="px-6 md:px-24 pb-20">
      <!-- Bandeau paiement validé -->
      <section class="max-w-4xl mx-auto mt-6">
        <div
          id="ghostops-studio-paid-banner"
          class="hidden mb-4 rounded-xl border border-emerald-500/70 bg-emerald-900/40 px-4 py-3 text-xs md:text-sm text-emerald-100"
        >
          <p class="font-semibold mb-1">Paiement GhostOps Studio Scénarios confirmé.</p>
          <p>
            Vous êtes dans l’espace IA dédié au
            <span class="font-semibold">Niveau&nbsp;2 – GhostOps Studio Scénarios</span>.
            Les échanges qui suivent servent à préparer vos
            <span class="font-semibold">2 à 3 scénarios tactiques</span>.
          </p>
        </div>
      </section>

      <!-- CONTEXTE NIVEAU 2 -->
      <section class="max-w-4xl mx-auto mt-4 mb-6">
        <p class="text-xs uppercase tracking-[.25em] text-gray-400 mb-3">
          GhostOps IA – Niveau&nbsp;2 · Studio Scénarios
        </p>
        <h1 class="text-2xl md:text-3xl font-bold mb-4 text-white text-shadow">
          Espace IA – GhostOps Studio Scénarios
        </h1>
        <p class="text-gray-200 text-sm md:text-base mb-3">
          Cet espace est réservé au <span class="font-semibold">Niveau&nbsp;2 de la suite GhostOps IA</span>. Il a
          pour objectif de transformer votre <span class="font-semibold">Diagnostic IA</span> ou votre dossier
          consolidé en <span class="font-semibold">2 à 3 scénarios tactiques comparables</span>.
        </p>
        <p class="text-gray-300 text-xs md:text-sm mb-3">
          L’IA GhostOps ne remplace pas l’intervention humaine ni les arbitrages de gouvernance. Elle sert ici à
          <span class="font-semibold">structurer les options</span>, clarifier les
          <span class="font-semibold">risques / gains / expositions</span> et tester différentes lignes d’action.
        </p>
        <p class="text-gray-400 text-[11px] md:text-xs">
          Évitez de saisir des noms complets ou des données directement identifiantes. Restez centré sur les fonctions, les comportements,
          les rapports de force et les enjeux (humains, politiques, réputationnels).
        </p>
      </section>

      <!-- CARTOUCHE DE TRAVAIL IA -->
      <section class="max-w-4xl mx-auto">
        <div class="bg-gray-900/80 border border-gray-700 rounded-2xl p-5 md:p-6">
          <div class="flex items-start justify-between gap-4">
            <h2 class="text-lg md:text-xl font-semibold text-white text-shadow">
              Atelier IA – Construction de scénarios tactiques
            </h2>

            <!-- Statut session -->
            <div class="flex flex-col items-end gap-1">
              <div
                id="ghostops-studio-status"
                class="ghostops-chip hidden text-[11px] md:text-xs px-3 py-2 rounded-xl text-gray-200"
              >
                <div class="flex items-center gap-2">
                  <span class="ghostops-muted">Itérations :</span>
                  <span id="ghostops-studio-iters" class="font-semibold">—</span>
                  <span class="ghostops-muted">· Expire :</span>
                  <span id="ghostops-studio-exp" class="font-semibold">—</span>
                </div>
              </div>
              <div id="ghostops-studio-status-hint" class="hidden text-[11px] md:text-xs text-gray-400">
                Session active (token côté client).
              </div>
            </div>
          </div>

          <div class="mt-5">
            <!-- Zone messages -->
            <div
              id="ghostops-studio-messages"
              class="bg-gray-950/80 border border-gray-800 rounded-xl px-3 py-3 h-64 md:h-80 overflow-y-auto text-xs md:text-sm space-y-2"
            >
              <div class="text-gray-200 text-xs md:text-[13px]">
                <span class="font-semibold">GhostOps IA – Studio Scénarios&nbsp;:</span>
                <span>
                  Pour commencer, décrivez votre situation en précisant&nbsp;: (1) le contexte, (2) les acteurs et leurs positions,
                  (3) ce que vous cherchez surtout à éviter, (4) ce qui serait considéré comme une issue acceptable.
                  <br /><br />
                  Je répondrai avec une première structuration et 2 à 3 scénarios à approfondir.
                </span>
              </div>
            </div>

            <!-- Bouton suite -->
            <div class="mt-3 flex items-center gap-2">
              <button
                id="ghostops-studio-continue"
                type="button"
                class="hidden ghostops-btn text-xs md:text-sm px-4 py-2 rounded-md bg-gray-900/70 hover:bg-gray-800 text-gray-100"
              >
                Demander la suite
              </button>
              <span id="ghostops-studio-continue-hint" class="hidden text-[11px] md:text-xs text-gray-400">
                La suite ne consomme pas d’itération.
              </span>
            </div>

            <!-- Form -->
            <form id="ghostops-studio-form" class="mt-3 flex flex-col gap-2 md:flex-row md:items-end">
              <textarea
                id="ghostops-studio-input"
                class="flex-1 text-xs md:text-sm bg-gray-900 text-gray-100 border border-gray-700 rounded-md px-2 py-2 resize-none focus:outline-none focus:border-gray-400"
                rows="3"
                placeholder="Décrivez votre situation (contexte, acteurs, contraintes, ce que vous cherchez à sécuriser)…"
              ></textarea>
              <button
                id="ghostops-studio-send"
                type="submit"
                class="mt-1 md:mt-0 md:ml-2 text-xs md:text-sm px-4 py-2 bg-white text-black font-semibold rounded-md hover:bg-gray-200"
              >
                Envoyer
              </button>
            </form>

            <div class="mt-2 flex items-center justify-between gap-3">
              <p class="text-[11px] md:text-xs text-gray-500">
                Cet espace IA prépare les scénarios. La validation finale, le cadrage des décisions et les communications sensibles restent assumés par des humains.
              </p>
              <p id="ghostops-studio-timeout-hint" class="hidden text-[11px] md:text-xs text-gray-400">
                Astuce : si un délai survient, réessayez (ou découpez votre message).
              </p>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="w-full px-6 md:px-24 pb-8 mt-10 text-xs text-gray-400">
      <div class="max-w-5xl mx-auto flex flex-col md:flex-row md:items-center md:justify-between gap-2">
        <p>© GhostOps – Tous droits réservés.</p>
        <nav class="flex flex-wrap items-center gap-3">
          <a href="/" class="hover:underline">Accueil</a>
          <a href="/expertise.html" class="hover:underline">Expertise</a>
          <a href="/qui-sommes-nous.html" class="hover:underline">Qui sommes-nous&nbsp;?</a>
          <a href="/contact.html" class="hover:underline">Contact</a>
          <a href="/mentions-legales.html" class="hover:underline">Mentions légales &amp; confidentialité</a>
        </nav>
      </div>
    </footer>

    <!-- ✅ Logique session Studio Scénarios -->
    <script>
      (function () {
        const TRUNC_MARKER = "— FIN TRONQUÉE (demander la suite)";
        const API_PATH = "/api/ghostops-studio-scenarios";
        const FRONT_TIMEOUT_MS = 35000;

        const params = new URLSearchParams(window.location.search);
        const csId = (params.get("cs_id") || "").trim();
        const paid = params.get("paid");
        const activated = params.get("activated");
        const paidBanner = document.getElementById("ghostops-studio-paid-banner");

        if ((paid === "1" || activated === "1" || csId) && paidBanner) paidBanner.classList.remove("hidden");

        const form = document.getElementById("ghostops-studio-form");
        const input = document.getElementById("ghostops-studio-input");
        const btnSend = document.getElementById("ghostops-studio-send");
        const messages = document.getElementById("ghostops-studio-messages");

        const btnContinue = document.getElementById("ghostops-studio-continue");
        const hintContinue = document.getElementById("ghostops-studio-continue-hint");

        const statusBox = document.getElementById("ghostops-studio-status");
        const statusHint = document.getElementById("ghostops-studio-status-hint");
        const itersEl = document.getElementById("ghostops-studio-iters");
        const expEl = document.getElementById("ghostops-studio-exp");
        const timeoutHint = document.getElementById("ghostops-studio-timeout-hint");

        if (!form || !input || !messages || !btnSend) return;

        // -------------------------
        // État session
        // -------------------------
        const storageKey = csId ? `ghostops_studio_session_${csId}` : "ghostops_studio_session_no_cs";
        let sessionToken = "";
        let itersLeft = null;
        let expiresAt = null; // unix seconds
        let lastAssistantForContinue = "";
        let history = []; // {role:"user"|"assistant", content:"..."}

        // -------------------------
        // Helpers UI
        // -------------------------
        function scrollToBottom() {
          messages.scrollTop = messages.scrollHeight;
        }

        function setDisabled(disabled) {
          if (disabled) {
            btnSend.classList.add("disabled");
            input.classList.add("disabled");
            input.setAttribute("disabled", "disabled");
          } else {
            btnSend.classList.remove("disabled");
            input.classList.remove("disabled");
            input.removeAttribute("disabled");
          }
        }

        function nowSec() {
          return Math.floor(Date.now() / 1000);
        }

        function formatParisDateTime(unixSec) {
          if (!unixSec) return "—";
          try {
            const d = new Date(unixSec * 1000);
            return new Intl.DateTimeFormat("fr-FR", {
              timeZone: "Europe/Paris",
              hour: "2-digit",
              minute: "2-digit",
              day: "2-digit",
              month: "2-digit",
            }).format(d);
          } catch (_) {
            return "—";
          }
        }

        function addMessageBubble(sender) {
          const wrapper = document.createElement("div");
          wrapper.className = sender === "user" ? "text-right" : "text-left";

          const bubble = document.createElement("div");
          bubble.className =
            sender === "user"
              ? "inline-block bg-blue-500 text-white text-xs md:text-sm px-3 py-2 rounded-lg mb-1"
              : "inline-block bg-gray-800 text-gray-100 text-xs md:text-sm px-3 py-2 rounded-lg mb-1 bot-bubble";

          wrapper.appendChild(bubble);
          messages.appendChild(wrapper);
          scrollToBottom();
          return bubble;
        }

        function hideContinue() {
          btnContinue.classList.add("hidden");
          hintContinue.classList.add("hidden");
        }

        function showContinue() {
          btnContinue.classList.remove("hidden");
          hintContinue.classList.remove("hidden");
        }

        function escapeHtml(str) {
          return String(str || "")
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
        }

        function stripTruncMarker(text) {
          const t = String(text || "");
          if (!t.includes(TRUNC_MARKER)) return { cleaned: t, truncated: false };
          return { cleaned: t.replace(TRUNC_MARKER, "").trim(), truncated: true };
        }

        function formatAiTextToHtml(raw) {
          const text = String(raw || "").replace(/\r\n/g, "\n").trim();
          if (!text) return "";

          const lines = text.split("\n");
          let html = "";
          let inUl = false;

          const closeUl = () => {
            if (inUl) {
              html += "</ul>";
              inUl = false;
            }
          };

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            if (!line.trim()) {
              closeUl();
              html += `<p class="mt-2"></p>`;
              continue;
            }

            if (line.trim().startsWith("- ")) {
              if (!inUl) {
                html += "<ul>";
                inUl = true;
              }
              let li = line.trim().slice(2);
              li = escapeHtml(li);
              li = li.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
              html += `<li>${li}</li>`;
              continue;
            }

            const m = line.trim().match(/^\*\*(.+?)\*\*$/);
            if (m) {
              closeUl();
              const title = escapeHtml(m[1]);
              html += `<p class="section-title"><strong>${title}</strong></p>`;
              continue;
            }

            closeUl();
            let p = escapeHtml(line).replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
            html += `<p>${p}</p>`;
          }

          closeUl();
          html = html.replace(/(<p class="mt-2"><\/p>\s*){3,}/g, '<p class="mt-2"></p><p class="mt-2"></p>');
          return html;
        }

        async function typewriterText(el, fullText, speedMs) {
          el.textContent = "";
          const txt = String(fullText || "");
          for (let i = 0; i < txt.length; i++) {
            el.textContent += txt[i];
            if (i % 2 === 0) scrollToBottom();
            await new Promise((r) => setTimeout(r, speedMs));
          }
          scrollToBottom();
        }

        function updateStatusUI() {
          const hasSession = Boolean(sessionToken) || typeof itersLeft === "number" || typeof expiresAt === "number";
          if (!hasSession) {
            statusBox.classList.add("hidden");
            statusHint.classList.add("hidden");
            return;
          }

          statusBox.classList.remove("hidden");
          statusHint.classList.remove("hidden");

          itersEl.textContent = typeof itersLeft === "number" ? String(itersLeft) : "—";
          expEl.textContent = expiresAt ? formatParisDateTime(expiresAt) : "—";

          const expired = expiresAt && nowSec() > expiresAt;
          const depleted = typeof itersLeft === "number" && itersLeft <= 0;

          if (expired || depleted) setDisabled(true);
          else setDisabled(false);
        }

        function saveSessionToStorage() {
          try {
            const payload = {
              sessionToken,
              itersLeft,
              expiresAt,
              history,
              lastAssistantForContinue,
              savedAt: Date.now(),
            };
            localStorage.setItem(storageKey, JSON.stringify(payload));
          } catch (_) {}
        }

        function loadSessionFromStorage() {
          try {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return false;
            const obj = JSON.parse(raw);
            if (!obj || typeof obj !== "object") return false;

            sessionToken = typeof obj.sessionToken === "string" ? obj.sessionToken : "";
            itersLeft = typeof obj.itersLeft === "number" ? obj.itersLeft : null;
            expiresAt = typeof obj.expiresAt === "number" ? obj.expiresAt : null;

            history = Array.isArray(obj.history) ? obj.history.slice(0, 50) : [];
            lastAssistantForContinue =
              typeof obj.lastAssistantForContinue === "string" ? obj.lastAssistantForContinue : "";

            return Boolean(sessionToken || itersLeft !== null || expiresAt !== null);
          } catch (_) {
            return false;
          }
        }

        function clearSessionStorage() {
          try {
            localStorage.removeItem(storageKey);
          } catch (_) {}
        }

        function pushUserToHistory(userText) {
          history.push({ role: "user", content: userText });
          if (history.length > 40) history = history.slice(history.length - 40);
        }

        async function renderBotReply(replyRaw) {
          const raw = String(replyRaw || "");
          const { cleaned, truncated } = stripTruncMarker(raw);

          lastAssistantForContinue = cleaned;

          const bubble = addMessageBubble("bot");
          await typewriterText(bubble, cleaned, 8);

          const html = formatAiTextToHtml(cleaned);
          if (html) bubble.innerHTML = html;

          if (truncated) showContinue();
          else hideContinue();

          history.push({ role: "assistant", content: cleaned });
          saveSessionToStorage();
        }

        function mergeSessionFromApi(data) {
          if (!data || typeof data !== "object") return;

          if (typeof data.sessionToken === "string" && data.sessionToken) sessionToken = data.sessionToken;
          if (typeof data.itersLeft === "number") itersLeft = data.itersLeft;
          if (typeof data.expiresAt === "number") expiresAt = data.expiresAt;

          updateStatusUI();
          saveSessionToStorage();
        }

        async function callApi(payload) {
          const controller = new AbortController();
          const t = setTimeout(() => controller.abort(), FRONT_TIMEOUT_MS);

          try {
            const resp = await fetch(API_PATH, {
              method: "POST",
              signal: controller.signal,
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            let data = {};
            try { data = await resp.json(); } catch (_) {}

            return { ok: resp.ok, status: resp.status, data };
          } catch (err) {
            if (err && err.name === "AbortError") {
              return {
                ok: false,
                status: 0,
                data: { error: "Temps de réponse dépassé. Veuillez réessayer." },
                timeout: true,
              };
            }
            return { ok: false, status: 0, data: { error: "Erreur réseau. Veuillez réessayer." } };
          } finally {
            clearTimeout(t);
          }
        }

        async function injectSupabaseToken(payload) {
          try {
            const sb = window.ghostopsSupabase;
            if (sb?.auth?.getSession) {
              const { data: s } = await sb.auth.getSession();
              const accessToken = s?.session?.access_token;
              if (accessToken) payload.supabaseAccessToken = accessToken;
            }
          } catch (_) {}
        }

        async function sendUserMessage() {
          hideContinue();
          timeoutHint.classList.add("hidden");

          const userText = (input.value || "").trim();
          if (!userText) return;

          if (userText.length > 4000) {
            const b = addMessageBubble("bot");
            b.textContent = "Message trop long. Merci de condenser (max ~4000 caractères) ou de découper en 2 envois.";
            return;
          }

          const userBubble = addMessageBubble("user");
          userBubble.textContent = userText;
          pushUserToHistory(userText);

          input.value = "";

          const waiting = addMessageBubble("bot");
          waiting.textContent = "Lecture scénarios en cours…";

          try {
            const payload = sessionToken
              ? { sessionToken, message: userText, history }
              : { message: userText, history };

            await injectSupabaseToken(payload);

            // Compat : si backend exige cs_id pour init, on le fournit si dispo
            if (!sessionToken && csId) payload.cs_id = csId;

            const { ok, status, data, timeout } = await callApi(payload);

            if (waiting && waiting.parentNode) waiting.parentNode.removeChild(waiting);

            if (!ok || !data || !data.reply) {
              const b = addMessageBubble("bot");
              if (status === 504 || timeout) {
                timeoutHint.classList.remove("hidden");
                b.textContent =
                  (data && data.error) ||
                  "Temps de génération dépassé. Réessayez, ou découpez votre message (ex: contexte puis acteurs puis contraintes).";
                return;
              }
              b.textContent = (data && data.error) || "Une erreur est survenue (Studio Scénarios). Veuillez réessayer.";
              return;
            }

            mergeSessionFromApi(data);
            await renderBotReply(data.reply);
          } catch (err) {
            console.error("Erreur sendUserMessage :", err);
            if (waiting && waiting.parentNode) waiting.parentNode.removeChild(waiting);
            const b = addMessageBubble("bot");
            b.textContent = "Erreur de connexion à GhostOps IA. Veuillez réessayer ou utiliser la page contact.";
          }
        }

        async function requestContinue() {
          timeoutHint.classList.add("hidden");
          if (!sessionToken || !lastAssistantForContinue) return;

          const waiting = addMessageBubble("bot");
          waiting.textContent = "Suite en cours…";

          try {
            const payload = {
              sessionToken,
              continue: true,
              last_assistant: lastAssistantForContinue,
              history,
            };

            await injectSupabaseToken(payload);

            const { ok, status, data, timeout } = await callApi(payload);

            if (waiting && waiting.parentNode) waiting.parentNode.removeChild(waiting);

            if (!ok || !data || !data.reply) {
              const b = addMessageBubble("bot");
              if (status === 504 || timeout) {
                timeoutHint.classList.remove("hidden");
                b.textContent = (data && data.error) || "Temps dépassé sur la suite. Réessayez.";
                return;
              }
              b.textContent = (data && data.error) || "Impossible de récupérer la suite. Veuillez réessayer.";
              return;
            }

            mergeSessionFromApi(data);
            await renderBotReply(data.reply);
          } catch (err) {
            console.error("Erreur continue :", err);
            if (waiting && waiting.parentNode) waiting.parentNode.removeChild(waiting);
            const b = addMessageBubble("bot");
            b.textContent = "Erreur lors de la récupération de la suite. Veuillez réessayer.";
          }
        }

        // -------------------------
        // Events
        // -------------------------
        form.addEventListener("submit", function (e) {
          e.preventDefault();
          sendUserMessage();
        });

        input.addEventListener("keydown", function (e) {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendUserMessage();
          }
        });

        btnContinue.addEventListener("click", function () {
          requestContinue();
        });

        // -------------------------
        // Init : restauration session
        // -------------------------
        hideContinue();

        const restored = loadSessionFromStorage();

        if (expiresAt && nowSec() > expiresAt) {
          clearSessionStorage();
          sessionToken = "";
          itersLeft = null;
          expiresAt = null;
          lastAssistantForContinue = "";
          history = [];
        }

        // Ne bloque plus sur l’absence de cs_id : modèle "droits" + auth-guard
        setDisabled(false);

        if (restored) updateStatusUI();
        else updateStatusUI();
      })();
    </script>
  </body>
</html>
